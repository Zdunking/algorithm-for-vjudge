# HDU-1495

## 非常可乐

` 地址https://vjudge.net/article/187`

### Descriptions：

`大家一定觉的运动以后喝可乐是一件很惬意的事情，但是seeyou却不这么认为。因为每次当seeyou买了可乐以后，阿牛就要求和seeyou一起分享这一瓶可乐，而且一定要喝的和seeyou一样多。但seeyou的手中只有两个杯子，它们的容量分别是N 毫升和M 毫升 可乐的体积为S （S<101）毫升　(正好装满一瓶) ，它们三个之间可以相互倒可乐 (都是没有刻度的，且 S==N+M，101＞S＞0，N＞0，M＞0) 。聪明的ACMER你们说他们能平分吗？如果能请输出倒可乐的最少的次数，如果不能输出"NO"。`

### Input


`三个整数 : S 可乐的体积 , N 和 M是两个杯子的容量，以"0 0 0"结束。`

### OutPut

`如果能平分的话请输出最少要倒的次数，否则输出"NO"。`

### Sample Input

```
7 4 3
4 1 3
0 0 0
```

### Sample Output

```
NO
3
```

### 思路

#### 科普
`为什么 BFS 能保证最少步骤？`
```
BFS 的搜索方式是 “按层次扩散” 的：
初始状态在第 0 层（步骤 0）。
从初始状态通过 1 步操作能到达的所有状态在第 1 层。
从第 1 层状态通过 1 步操作能到达的所有状态在第 2 层。
以此类推，每一层的状态对应的步骤数都等于层数。
在你的代码中，当 BFS 首次找到满足条件的状态（两个容器为s/2）时，这个状态所在的 “层数” 就是到达该状态的最少步骤数。因为：
此时队列中所有比它 “层数低”（步骤少）的状态都已经被检查过了（且未满足条件）。
后续队列中还未检查的状态，其步骤数一定大于等于当前找到的步骤数（因为 BFS 按顺序逐层处理）。
因此，首次找到的解必然是最少步骤，不可能存在 “更优解”（步骤更少的解）。
```

### Code

见 chapter1  HDU1495函数