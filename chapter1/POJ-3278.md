# POJ-3278

## **Catch That Cow**

` 地址https://vjudge.net/article/187`

### Descriptions：

`Farmer John has been informed of the location of a fugitive cow and wants to catch her immediately. He starts at a point *N* (0 ≤ *N* ≤ 100,000) on a number line and the cow is at a point *K* (0 ≤ *K* ≤ 100,000) on the same number line. Farmer John has two modes of transportation: walking and teleporting.`

\`* Walking: FJ can move from any point *X* to the points *X* - 1 or *X* + 1 in a single minute	`
\* Teleporting: FJ can move from any point *X* to the point 2 × *X* in a single minute.`

`If the cow, unaware of its pursuit, does not move at all, how long does it take for Farmer John to retrieve it?`

### Input

`Line 1: Two space-separated integers: *N* and *K*`

### OutPut

`Line 1: The least amount of time, in minutes, it takes for Farmer John to catch the fugitive cow.`

### Sample Input

```
5 17
```

### Sample Output

```
4
```

### 思路

问题描述是：一个农夫在位置 n，他的牛在位置 k。农夫有三种移动方式：

1. 从 x 移动到 x-1，耗时 1 单位
2. 从 x 移动到 x+1，耗时 1 单位
3. 从 x 移动到 x*2，耗时 1 单位

我们需要找到农夫抓到牛的最短时间。

- BFS 非常适合解决这种寻找最短路径的问题
- `queue<PII> q` 队列存储待访问的位置及其到达时间
- 首先将农夫的初始位置 n 和时间 0 入队，并标记为已访问
- 当队列不为空时，取出队首元素：
  - 如果当前位置等于牛的位置 k，输出时间并结束搜索
  - 否则，尝试三种移动方式：
    1. 位置减一：检查是否合法（>=0）且未访问过
    2. 位置加一：检查是否合法（<=N）且未访问过
    3. 位置乘二：检查是否合法（<=N）且未访问过
  - 对每种合法的移动，标记为已访问并加入队列，时间加 1



### Code

见 chapter1  POJ1321函数